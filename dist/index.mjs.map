{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { ref, inject, type Ref, type App, type Plugin, unref } from \"vue\";\n\n/**\n * Configuration options for creating an i18n instance.\n */\ninterface I18nOptions {\n    /**\n     * The initial locale to use.\n     */\n    locale: string;\n    /**\n     * The fallback locale when translation is missing.\n     */\n    fallbackLocale: string;\n\n    /**\n     * Messages object with translations for different locales.\n     */\n    messages: Record<string, any>;\n\n    /**\n     * Whether to warn on missing translations, defaults to true.\n     */\n    missingWarn?: boolean;\n\n    /**\n     * Whether to inject globally in the same way as Vue I18n, defaults to true.\n     */\n    globalInject?: boolean;\n\n    /**\n     * The global name to use for the i18n instance when globally injected.\n     */\n    globalInjectPrefix?: string;\n\n    /**\n     * The custom rules for pluralization, return the plural form index based on the count.\n     */\n    customPluralRules?: Record<string, PluralRule>;\n}\n\n/**\n * The main i18n instance interface providing translation and locale management.\n */\nexport interface I18nInstance {\n    /**\n     * Translates a key into the current locale's string, optionally interpolating parameters.\n     * @param key - The translation key\n     * @param params - Optional parameters for interpolation, can be a reactive Ref or plain object\n     * @returns The translated string\n     */\n    t: (\n        key: string,\n        params?: Ref<Record<string, any>> | Record<string, any>,\n    ) => string;\n\n    /**\n     * Translates a key into the current locale's string, optionally interpolating parameters and handling pluralization.\n     * @param key - The translation key\n     * @param choice - The count used for pluralization\n     * @param params - Optional parameters for interpolation, can be a reactive Ref or plain object\n     * @returns The translated string\n     */\n    tc: (key: string, count: number, params?: Ref<Record<string, any>> | Record<string, any>) => string;\n    /**\n     * The current locale as a reactive Ref.\n     */\n    locale: Ref<string>;\n    /**\n     * Array of available locales in the messages object.\n     */\n    availableLocales: string[];\n    /**\n     * The messages object containing translations for all locales.\n     */\n    messages: Record<string, any>;\n    /**\n     * The fallback locale to use when translation is missing.\n     */\n    fallbackLocale: string;\n}\n\nexport type PluralRule = (n: number) => number;\n\nconst I18nInjectionKey = Symbol(\"i18n\");\n\n/**\n * Recursively flattens nested message objects into a flat map with dot-notation keys.\n *\n * @param messages - The nested messages object to flatten\n * @param prefix - Optional prefix for building dot-notation keys (used internally for recursion)\n * @returns A Map where keys are dot-notation paths and values are the translation strings\n */\nfunction flattenMessages(\n    messages: Record<string, any>,\n    prefix = \"\",\n): Map<string, string> {\n    const result = new Map<string, string>();\n\n    for (const key in messages) {\n        const fullKey = prefix ? `${prefix}.${key}` : key;\n        const value = messages[key];\n\n        if (typeof value === \"string\") {\n            result.set(fullKey, value);\n        } else if (typeof value === \"object\" && value !== null) {\n            const nested = flattenMessages(value, fullKey);\n            for (const [nestedKey, nestedValue] of nested) {\n                result.set(nestedKey, nestedValue);\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction constructPluralizationRulesMap(\n    customRules?: Record<string, PluralRule>,\n) {\n    const result = new Map<string, PluralRule>();\n\n    for (const key in defaultPluralRules) {\n        result.set(key, defaultPluralRules[key]);\n    }\n\n    if (!customRules) return result;\n\n    for (const key in customRules) {\n        result.set(key, customRules[key]);\n    }\n\n    return result;\n}\n\nexport const defaultPluralRules: Record<string, PluralRule> = {\n    zh: () => 0,\n    \"zh-CN\": () => 0,\n    \"zh-TW\": () => 0,\n    en: (n) => (n === 1 ? 0 : 1),\n    ja: () => 0,\n    ko: () => 0,\n    fr: (n) => (n === 0 || n === 1 ? 0 : 1),\n    de: (n) => (n === 1 ? 0 : 1),\n    es: (n) => (n === 1 ? 0 : 1),\n    ru: (n) => {\n        const mod10 = n % 10;\n        const mod100 = n % 100;\n        if (mod10 === 1 && mod100 !== 11) return 0;\n        if (mod10 >= 2 && mod10 <= 4 && (mod100 < 10 || mod100 >= 20)) return 1;\n        return 2;\n    },\n    pl: (n) => {\n        if (n === 1) return 0;\n        const mod10 = n % 10;\n        const mod100 = n % 100;\n        if (mod10 >= 2 && mod10 <= 4 && (mod100 < 10 || mod100 >= 20)) return 1;\n        return 2;\n    },\n    ar: (n) => {\n        if (n === 0) return 0;\n        if (n === 1) return 1;\n        if (n === 2) return 2;\n        if (n % 100 >= 3 && n % 100 <= 10) return 3;\n        if (n % 100 >= 11 && n % 100 <= 99) return 4;\n        return 5;\n    },\n};\n\n/**\n * Creates a new i18n instance with the provided options.\n *\n * @param options - Configuration options for the i18n instance\n * @returns An I18nInstance that also implements the Vue Plugin interface\n *\n * @example\n * ```ts\n * const i18n = createI18n({\n *   locale: 'en',\n *   fallbackLocale: 'en',\n *   messages: {\n *     en: { greeting: 'Hello {name}!' },\n *     fr: { greeting: 'Bonjour {name}!' }\n *     'zh-CN': { greeting: '你好 {name}！' }\n *   }\n * })\n *\n * app.use(i18n)\n * ```\n */\nexport function createI18n(options: I18nOptions): I18nInstance & Plugin {\n    const locale = ref(options.locale);\n    const messages = options.messages;\n    const fallbackLocale = options.fallbackLocale;\n    const availableLocales = Object.keys(messages);\n    const translationMap: Map<string, string> = flattenMessages(messages);\n    const pluralizationRules = constructPluralizationRulesMap(\n        options.customPluralRules,\n    );\n\n    function applyPlural(translation: string, count: number, locale: string): string {\n        const forms = translation.split(/\\s*\\|\\s*/).map(s => s.trim());\n        if (forms.length <= 1) return translation;\n\n        let rule = pluralizationRules.get(locale);\n        if (!rule) {\n            rule = pluralizationRules.get(fallbackLocale) ?? ((n) => n === 1 ? 0 : 1);\n        }\n\n        const index = rule(Math.abs(count));\n        return forms[Math.min(index, forms.length - 1)];\n    }\n\n    function getTranslation(key: string): string {\n        const translation = translationMap.get(`${locale.value}.${key}`)\n            ?? translationMap.get(`${fallbackLocale}.${key}`);\n\n        if (typeof translation !== \"undefined\") {\n            return translation;\n        }\n        else {\n            if (options.missingWarn !== false) {\n                console.warn(`[i18n (nano)] Missing translation for key: ${key}`);\n            }\n            return key;\n        }\n    }\n\n    function getPluralTranslation(key: string, count: number): string {\n        const translation = getTranslation(key);\n        return applyPlural(translation, count, locale.value);\n    }\n\n    const PARAM_REGEX = /\\{(\\w+)\\}/g;\n\n    function t(\n        key: string,\n        params?: Ref<Record<string, any>> | Record<string, any>,\n    ): string {\n        let translation = getTranslation(key);\n        if (!params) return translation;\n\n        const currentParams = unref(params);\n\n        translation = translation.replace(\n            PARAM_REGEX,\n            (match, paramName: string) => {\n                return paramName in currentParams\n                    ? String(currentParams[paramName])\n                    : match;\n            },\n        );\n\n        return translation;\n    }\n\n    function tc(key: string, count: number, params?: Ref<Record<string, any>> | Record<string, any>)  {\n        if (isNaN(count)) {\n            if (options.missingWarn !== false) {\n                console.warn(\n                    `[i18n (nano)] Plural parameter is NaN`\n                );\n            }\n            return getTranslation(key);\n        }\n\n        let translation = getPluralTranslation(key, count);\n        if (!params) return translation;\n\n        const currentParams = unref(params);\n        return translation.replace(PARAM_REGEX, (match, paramName: string) => {\n            return paramName in currentParams\n                ? String(currentParams[paramName])\n                : match;\n        });\n    }\n\n    const instance: I18nInstance = {\n        t,\n        tc,\n        locale,\n        availableLocales,\n        messages: messages,\n        fallbackLocale,\n    };\n\n    const plugin: Plugin = {\n        install(app: App) {\n            app.provide(I18nInjectionKey, instance);\n            if (options.globalInject !== false) {\n                if (options.globalInjectPrefix?.length) {\n                    app.config.globalProperties[\n                        `$${options.globalInjectPrefix}T`\n                    ] = t;\n                    app.config.globalProperties[\n                        `$${options.globalInjectPrefix}I18n`\n                    ] = instance;\n                    app.config.globalProperties[\n                        `$${options.globalInjectPrefix}Locale`\n                    ] = locale;\n                    app.config.globalProperties[\n                        `$${options.globalInjectPrefix}Tc`\n                    ] = tc;\n                } else {\n                    app.config.globalProperties[`$t`] = t;\n                    app.config.globalProperties[`$i18n`] = instance;\n                    app.config.globalProperties[`$locale`] = locale;\n                    app.config.globalProperties[\n                        `$tc`\n                    ] = tc;\n                }\n            }\n        },\n    };\n\n    return Object.assign(instance, plugin);\n}\n\n/**\n * Retrieves the i18n instance from the Vue injection context.\n *\n * @returns The I18nInstance provided by the nearest createI18n ancestor\n * @throws Error if called before the i18n plugin is installed via app.use()\n *\n * @example\n * ```ts\n * const { t, locale } = useI18n()\n * console.log(t('greeting', { name: 'World' }))\n * ```\n */\nexport function useI18n(): I18nInstance {\n    const i18n = inject<I18nInstance>(I18nInjectionKey);\n\n    if (!i18n) {\n        throw new Error(\n            \"I18n (nano) instance not found. Did you forget to install the i18n plugin?\",\n        );\n    }\n\n    return i18n;\n}\n"],"mappings":"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","names":["ref","inject","unref","I18nInjectionKey","flattenMessages","messages","prefix","result","key","fullKey","value","nested","nestedKey","nestedValue","constructPluralizationRulesMap","customRules","defaultPluralRules","mod10","mod100","createI18n","options","locale","fallbackLocale","availableLocales","translationMap","pluralizationRules","applyPlural","translation","count","forms","s","rule","n","index","getTranslation","getPluralTranslation","PARAM_REGEX","t","params","currentParams","match","paramName","tc","instance","app","useI18n","i18n"]}